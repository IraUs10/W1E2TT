{
  // Операция?
  char op;
  if (cin >> op)
  {
    switch (op)
    {
      // Вычислить значение выражения (операнды уже известны -- x, y) и вернуть результат.
    case '+': return x + y;
    case '-': return x - y;
    case '*': return x * y;
    case '/': return x / y;
      // Не операция? вернуть считанный символ в поток.
    default: cin.unget();
    }
  }

  // Число?
  double z;
  if (cin >> z)
    return postfix(x, postfix(y, z));
  // Новые операнды -- y и считанное z.
  // Но x тоже никуда не делся. После того, как будет вычислено значение над ним,
  // может быть считана операция, которая задействует x. Отсюда второй рекурсивный вызов.
  // Этот последний вызов является хвостовым и может быть раскрыт в цикл.
  
  // Иначе конец ввода или ошибка, вернём последнее вычисленное значение (операнд y).
  return y;
}
